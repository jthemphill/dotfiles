\timing
\pset null 'âˆ…'
\set HISTCONTROL ignoredups
\set COMP_KEYWORD_CASE upper
\set rtsize '(select table_schema, table_name, pg_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) as size, pg_total_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) as total_size  from information_schema.tables where table_type = \'BASE TABLE\' and table_schema not in (\'information_schema\', \'pg_catalog\') order by pg_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) desc, table_schema, table_name)';
\set tsize '(select table_schema, table_name, pg_size_pretty(size) as size, pg_size_pretty(total_size) as total_size from (:rtsize) x order by x.size desc, x.total_size desc, table_schema, table_name)';
\set trashindexes '( select s.schemaname as sch, s.relname as rel, s.indexrelname as idx, s.idx_scan as scans, pg_size_pretty(pg_relation_size(s.relid)) as ts, pg_size_pretty(pg_relation_size(s.indexrelid)) as "is" from pg_stat_user_indexes s join pg_index i on i.indexrelid=s.indexrelid left join pg_constraint c on i.indrelid=c.conrelid and array_to_string(i.indkey, '' '') = array_to_string(c.conkey, '' '') where i.indisunique is false and pg_relation_size(s.relid) > 100000 and s.idx_scan < 10000 and c.confrelid is null order by s.idx_scan asc, pg_relation_size(s.relid) desc )';
\set missingindexes '( select src_table, dst_table, fk_name, pg_size_pretty(s_size) as s_size, pg_size_pretty(d_size) as d_size, d from ( select distinct on (1,2,3,4,5) textin(regclassout(c.conrelid)) as src_table, textin(regclassout(c.confrelid)) as dst_table, c.conname as fk_name, pg_relation_size(c.conrelid) as s_size, pg_relation_size(c.confrelid) as d_size, array_upper(di.indkey::int[], 1) + 1 - array_upper(c.conkey::int[], 1) as d from pg_constraint c left join pg_index di on di.indrelid = c.conrelid and array_to_string(di.indkey, '' '') ~ (''^'' || array_to_string(c.conkey, '' '') || ''( |$)'') join pg_stat_user_tables st on st.relid = c.conrelid where c.contype = ''f'' order by 1,2,3,4,5,6 asc) mfk where mfk.d is distinct from 0 and mfk.s_size > 100000 order by mfk.s_size desc, mfk.d desc )';
\set bigtables '(SELECT relname AS table_name, pg_size_pretty(pg_total_relation_size(C.oid)) AS total_size FROM pg_class C LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace) WHERE nspname NOT IN (''pg_catalog'', ''information_schema'') AND C.relkind <> ''i'' AND nspname !~ ''^pg_toast'' ORDER BY pg_total_relation_size(C.oid) DESC LIMIT 20)';
\set bigindexes '(SELECT t.tablename, indexname, c.reltuples AS num_rows, pg_relation_size(quote_ident(t.tablename)::text) AS table_size, pg_relation_size(quote_ident(indexrelname)::text) AS index_size, CASE WHEN x.is_unique = 1  THEN ''Y'' ELSE ''N'' END AS UNIQUE, idx_scan AS number_of_scans, idx_tup_read AS tuples_read, idx_tup_fetch AS tuples_fetched FROM pg_tables t LEFT OUTER JOIN pg_class c ON t.tablename=c.relname LEFT OUTER JOIN (SELECT indrelid, max(CAST(indisunique AS integer)) AS is_unique FROM pg_index GROUP BY indrelid) x ON c.oid = x.indrelid LEFT OUTER JOIN ( SELECT c.relname AS ctablename, ipg.relname AS indexname, x.indnatts AS number_of_columns, idx_scan, idx_tup_read, idx_tup_fetch,indexrelname FROM pg_index x JOIN pg_class c ON c.oid = x.indrelid JOIN pg_class ipg ON ipg.oid = x.indexrelid JOIN pg_stat_all_indexes psai ON x.indexrelid = psai.indexrelid ) AS foo ON t.tablename = foo.ctablename WHERE t.schemaname=''public'' ORDER BY 5 desc limit 42)';
\set active '(SELECT datname, procpid, now() - query_start AS runtime, case when waiting then \'WAIT\' else \'\' end AS wait, current_query FROM pg_stat_activity WHERE current_query <> \'<IDLE>\' AND procpid <> pg_backend_pid() ORDER BY runtime DESC)';
\set seq_scans '(select relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch from pg_stat_all_tables where schemaname=\'public\' and pg_relation_size(relname::regclass)>50000 and seq_tup_read > 100000 and seq_scan > 9 order by seq_scan desc)';
\set index_usage '(select s.relname, s.seq_tup_read + s.idx_tup_fetch usage, (s.idx_tup_fetch/s.seq_tup_read::float)::decimal(18,4) index_ratio, s.seq_tup_read, s.idx_tup_fetch, s.seq_scan, s.n_live_tup, ((io.heap_blks_hit + io.idx_blks_hit)/((io.heap_blks_read + io.idx_blks_read)::float))::decimal(18,4) cache_hit_ratio FROM pg_stat_user_tables s INNER JOIN pg_statio_user_tables io ON s.relid = io.relid WHERE s.seq_tup_read + s.idx_tup_fetch > 0 AND s.n_live_tup > 5000 ORDER BY usage desc, cache_hit_ratio desc, index_ratio asc, s.seq_scan desc, s.n_live_tup desc)';
\set index_unused '(select indexrelid::regclass as index, relid::regclass as table from pg_stat_user_indexes JOIN pg_index USING (indexrelid) where idx_scan = 0 and indisunique is false)';
\set index_dups '(select indrelid::regclass as table, array_agg(indexrelid::regclass) as duplicates from pg_index group by indrelid, indkey having count(*) > 1)';
\set index_in_multi '(select a.indrelid::regclass as table_name, a.indexrelid::regclass, b.indexrelid::regclass from (select *,array_to_string(indkey,\' \') as cols from pg_index) a join (select *,array_to_string(indkey,\' \') as cols from pg_index) b on (a.indrelid=b.indrelid and a.indexrelid > b.indexrelid and not a.indisunique and not b.indisunique and ((a.cols LIKE b.cols||\'%\' and coalesce(substr(a.cols,length(b.cols)+1,1),\' \')=\' \') or (b.cols LIKE a.cols||\'%\' and coalesce(substr(b.cols,length(a.cols)+1,1),\' \')=\' \'))) order by table_name)';
